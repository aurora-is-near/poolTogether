// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "openzeppelin-contracts/token/ERC20/IERC20.sol";
import "./interfaces/IJetStaking.sol";

/**
 * @title Aurora Yield Lottery
 * @author Aurora Team
 * 
 * @notice This contract allows users to pool together their aurora for a specified 
 *         period of time, afterwhich a user is selected at random as the "winner".
 *         The "winner" receives the combined yield generated by all users + initial 
 *         stake provided. All users are refunded their initial investment.
 * 
 * @dev Two key problems to solve for this are:
 *      - Mechanism to decide winner (one address one ticket, or one aurora one ticket, or something else?)
 *      - Where to get source of randomness - the EVM is inherently deterministic, hence its virtually impossible 
 *        to achieve this *within* the blockchain. Blockhash, blockTimestamp, nonce etc. can be gamed easily.
 * 
 *     Solution: The selection of the winner will be outsourced to a trusted admin. Said admin will receive a list 
 *               (via emitted events) of user addresses and their corresponding aurora staked, and will generate a winner.
 *               Would recommend to use one aurora one ticket - otherwise incentivises users to spread aurora across multiple wallets
 *     *Update: Solution for randomness has been updated - it no longer depends on an admin choosing the winner, but rather uses 
 *              a host function that pulls randomness from the NEAR blockchain.
 */

contract YieldLottery {
    // Window of time within which users can deposit aurora
    uint256 public openWindow;
    // Admin of the contract
    address public admin;
    // Allows control over deposits
    bool public paused;
    // Aurora token
    IERC20 public aurora;
    // Stream tokens
    IERC20[] public streamTokens;
    // JetStaking
    IJetStaking public jetStaking;
    // Array of epochs
    Epoch[] public epochs;
    // Mapping of epochId => address => Position
    mapping(uint256 => mapping(address => Position)) public userTickets;
    // Helper mapping for calculating winner
    mapping(uint256 => Tickets[]) public cumulativeTickets;

    enum Status {
        Active,
        Ended
    }

    struct Tickets {
        address owner;
        uint256 amountCumulative;
    }

    // Position represents a user's stake
    struct Position {
        uint256 amount;
        bool claimed;
    }

    // 1 Epoch == 1 "lottery game"
    struct Epoch {
        uint256 startTime;
        uint256 endTime;
        uint256 initialBal;
        uint256 finalBal;
        address winner;
        bool withdrawalOpen;
        Status status;
    }

    event Staked(address indexed user, uint256 indexed epochId, uint256 amount);

    modifier onlyAdmin() {
        require(msg.sender == admin, "ONLY_ADMIN_CAN_CALL");
        _;
    }

    modifier notPaused() {
        require(!paused, "CONTRACT_PAUSED");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
        paused = true;
    }

    // Initialization of state variables
    function init(uint256 _openWindow, address _aurora, address _jetStaking, address[] calldata _streamTokens)
        external
        onlyAdmin
    {
        openWindow = _openWindow;
        aurora = IERC20(_aurora);
        jetStaking = IJetStaking(_jetStaking);
        for (uint256 i; i < _streamTokens.length;) {
            streamTokens.push(IERC20(_streamTokens[i]));
            unchecked {
                i++;
            }
        }
        aurora.approve(address(jetStaking), type(uint256).max);
        newEpoch();
        paused = false;
    }

    // @notice Allows users to buy tickets in the current epoch
    // @param _amount Amount of aurora tokens to stake
    // @dev Function checks that the epoch is live and within the "betting window"
    //      It then updates a mapping and stakes the user's aurora tokens
    function buyTickets(uint256 _amount) external notPaused {
        uint epochId = epochs.length - 1;
        Epoch memory currentEpoch = epochs[epochId];
        require(currentEpoch.status == Status.Active, "NO_LIVE_EPOCHS");
        require(currentEpoch.startTime + openWindow > block.timestamp, "EPOCH_CLOSED");
        aurora.transferFrom(msg.sender, address(this), _amount);
        userTickets[epochId][msg.sender].amount += _amount;
        cumulativeTickets[epochId] = Tickets(msg.sender, currentEpoch.initialBal + _amount);
        epochs[epochId].initialBal += _amount;

        emit Staked(msg.sender, epochId, _amount);
    }

    // @notice Allows users to claim their tokens after epoch is finished
    // @param _epochId Epoch that they want to claim their tokens for
    // @dev Function makes sure said epoch: is concluded, the 2 day withdrawal wait
    //      is over. and user hasn't already claimed. It then transfers the user's
    //      initial depposit back, and checks if the user is the winner to send the
    //      yield generated.
    function claimTickets(uint256 _epochId) public {
        Epoch memory epoch = epochs[_epochId];
        require(epoch.status == Status.Ended, "EPOCH_NOT_CONCLUDED");
        require(epoch.withdrawalOpen, "WITHDRAWAL_UNAVAILABLE");
        require(!userTickets[_epochId][msg.sender].claimed, "ALREADY_CLAIMED");
        uint256 balance = userTickets[_epochId][msg.sender].amount;
        aurora.transfer(msg.sender, balance);
        if (epoch.winner == msg.sender) {
            uint256 prize = epoch.finalBal - epoch.initialBal;
            aurora.transfer(msg.sender, prize);
            for (uint256 i; i < streamTokens.length;) {
                uint256 bal = streamTokens[i].balanceOf(address(this));
                streamTokens[i].transfer(msg.sender, bal);
                unchecked {
                    i++;
                }
            }
        }
        userTickets[_epochId][msg.sender].claimed = true;
    }

    function claimLatest() external {
        claimTickets(epochs.length - 2);
    }

    // @notice Allows admin to close an epoch and computes the winner
    // @dev Function updates epoch variables and moves all rewardstoPending.
    function concludeEpoch() external onlyAdmin {
        Epoch storage currentEpoch = epochs[epochs.length - 1];
        require(currentEpoch.status == Status.Active, "NO_LIVE_EPOCH");
        address winner = computeWinner(epochs.length - 1);
        currentEpoch.endTime = block.timestamp;
        currentEpoch.winner = winner;
        currentEpoch.status = Status.Ended;
        uint256 auroraBal = (jetStaking.getTotalAmountOfStakedAurora() * jetStaking.getUserShares(address(this)))
            / jetStaking.totalAuroraShares();
        currentEpoch.finalBal = auroraBal;
        jetStaking.moveAllRewardsToPending();
        jetStaking.unstakeAll();
    }

    // @notice Allows admin to withdraw tokens once the 2 day delay is over
    // @notice _epochId Allows function to know which epochId to update
    function withdraw(uint256 _epochId) external onlyAdmin {
        jetStaking.withdrawAll();
        epochs[_epochId].withdrawalOpen = true;
    }

    // @notice Creates a new epoch and pushes to the array
    function newEpoch() public onlyAdmin {
        epochs.push(Epoch(block.timestamp, 0, 0, 0, address(0), false, Status.Active));
    }

    /*/////////////////////////////////////////////////////
                    HELPER FUNCTIONS
    /////////////////////////////////////////////////////*/

    function randomSeed() public returns (uint256) {
        bytes32[1] memory value;

        assembly {
            let ret := call(gas(), 0xc104f4840573bed437190daf5d2898c2bdf928ac, 0, 0, 0, value, 32)
        }

        return uint256(value[0]);
    }

    // @notice Function computes the winner for a specific epoch
    // @param epochId Id of epoch we want to compute winner for
    // @dev The winner is computed by getting a random uint256 number
    //      We then divide this random number by the total aurora deposited
    //      in the specified epoch, and take the remainder. (we add 1 because
    //      the modulo can be 0 - n-1, and we need a number from 1 to n)
    //      Whicheve address has a *cumulative* aurora balance higher than the
    //      winning number is the winning address.
    function computeWinner(uint256 epochId) public returns (address) {
        uint256 randNum = randomSeed();
        uint256 totalAurora = epochs[epochId].finalBal;
        uint256 winningNum = (randNum % totalAurora) + 1;
        Tickets[] memory tickets = cumulativeTickets[epochId];
        uint256 _length = tickets.length;
        for(uint i; i < _length;) {
            if(tickets[i].amountCumulative >= winningNum) {
                return tickets[i].owner;
            }
            unchecked {
                ++i;
            }
        }
    }

    function stake() external onlyAdmin {
        jetStaking.stake(aurora.balanceOf(address(this)));
    }

    function setAdmin(address _admin) external onlyAdmin {
        admin = _admin;
    }

    function setOpenWindow(uint256 _time) external onlyAdmin {
        openWindow = _time;
    }

    function pause() external onlyAdmin {
        paused = true;
    }

    function unPause() external onlyAdmin {
        paused = false;
    }

}
