// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "openzeppelin-contracts/token/ERC20/IERC20.sol";
import "./interfaces/IJetStaking.sol";

/**

   _____                                     .__          __    __                       
  /  _  \  __ _________  ________________    |  |   _____/  |__/  |_  ___________ ___.__.
 /  /_\  \|  |  \_  __ \/  _ \_  __ \__  \   |  |  /  _ \   __\   __\/ __ \_  __ <   |  |
/    |    \  |  /|  | \(  <_> )  | \// __ \_ |  |_(  <_> )  |  |  | \  ___/|  | \/\___  |
\____|__  /____/ |__|   \____/|__|  (____  / |____/\____/|__|  |__|  \___  >__|   / ____|
        \/                               \/                              \/       \/     

 * @title Aurora Yield Lottery
 * @author Aurora Team
 *
 * @notice This contract allows users to pool together their aurora for a specified
 *         period of time, afterwhich a user is selected at random as the "winner".
 *         The "winner" receives the combined yield generated by all users + initial
 *         stake provided. All users are refunded their initial investment.
 *
 * @dev Two key problems to solve for this are:
 *      - Mechanism to decide winner (one address one ticket, or one aurora one ticket, or something else?)
 *      - Where to get source of randomness - the EVM is inherently deterministic, hence its virtually impossible
 *        to achieve this *within* the blockchain. Blockhash, blockTimestamp, nonce etc. can be gamed easily.
 *
 *     Solution: The source of randomness is achieved thanks to the NEAR blockchain including a random number in
 *               every block. This number is then used to select a winner. There is one caveat however, which is
 *               that near validators can choose to not produce a block if the random number is "not of their liking"
 *               However, I believe this will have minimal impact as this "manipulation" comes with a lot of reputational
 *               and potentially financial cost to the validator.
 */

contract YieldLotteryBsearch {
    // Window of time within which users can deposit aurora
    uint256 public openWindow;
    // Admin of the contract
    address public admin;
    // Allows control over deposits
    bool public paused;
    // Aurora token
    IERC20 public aurora;
    // Stream tokens
    IERC20[] public streamTokens;
    // JetStaking
    IJetStaking public jetStaking;
    // Array of epochs
    Epoch[] public epochs;
    // Mapping of epochId => address => Position
    mapping(uint256 => mapping(address => Position)) public userTickets;
    // Helper mapping for calculating winner
    mapping(uint256 => Tickets[]) public cumulativeTickets;

    enum Status {
        Active,
        Ended
    }

    struct Tickets {
        address owner;
        uint256 amountCumulative;
    }

    // Position represents a user's stake
    struct Position {
        uint256 amount;
        bool claimed;
    }

    // 1 Epoch == 1 "lottery game"
    struct Epoch {
        uint256 startTime;
        uint256 endTime;
        uint256 initialBal;
        uint256 finalBal;
        address winner;
        bool withdrawalOpen;
        Status status;
    }

    event Staked(address indexed user, uint256 indexed epochId, uint256 amount);

    modifier onlyAdmin() {
        require(msg.sender == admin, "ONLY_ADMIN_CAN_CALL");
        _;
    }

    modifier notPaused() {
        require(!paused, "CONTRACT_PAUSED");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
        paused = true;
    }

    // Initialization of state variables
    function init(uint256 _openWindow, address _aurora, address _jetStaking, address[] calldata _streamTokens)
        external
        onlyAdmin
    {
        openWindow = _openWindow;
        aurora = IERC20(_aurora);
        jetStaking = IJetStaking(_jetStaking);
        for (uint256 i; i < _streamTokens.length;) {
            streamTokens.push(IERC20(_streamTokens[i]));
            unchecked {
                i++;
            }
        }
        aurora.approve(address(jetStaking), type(uint256).max);
        newEpoch();
        paused = false;
    }

    // @notice Allows users to buy tickets in the current epoch
    // @param _amount Amount of aurora tokens to stake
    // @dev Function checks that the epoch is live and within the "betting window"
    //      It then updates a mapping and stakes the user's aurora tokens
    function buyTickets(uint256 _amount) external notPaused {
        uint256 epochId = epochs.length - 1;
        Epoch memory currentEpoch = epochs[epochId];
        require(currentEpoch.status == Status.Active, "NO_LIVE_EPOCHS");
        require(currentEpoch.startTime + openWindow > block.timestamp, "EPOCH_CLOSED");
        aurora.transferFrom(msg.sender, address(this), _amount);
        userTickets[epochId][msg.sender].amount += _amount;
        cumulativeTickets[epochId].push(Tickets(msg.sender, currentEpoch.initialBal + _amount));
        epochs[epochId].initialBal += _amount;

        emit Staked(msg.sender, epochId, _amount);
    }

    // @notice Allows users to claim their tokens after epoch is finished
    // @param _epochId Epoch that they want to claim their tokens for
    // @dev Function makes sure said epoch: is concluded, the 2 day withdrawal wait
    //      is over. and user hasn't already claimed. It then transfers the user's
    //      initial depposit back, and checks if the user is the winner to send the
    //      yield generated.
    function claimTickets(uint256 _epochId) public {
        Epoch memory epoch = epochs[_epochId];
        require(epoch.status == Status.Ended, "EPOCH_NOT_CONCLUDED");
        require(epoch.withdrawalOpen, "WITHDRAWAL_UNAVAILABLE");
        require(!userTickets[_epochId][msg.sender].claimed, "ALREADY_CLAIMED");
        uint256 balance = userTickets[_epochId][msg.sender].amount;
        aurora.transfer(msg.sender, balance);
        if (epoch.winner == msg.sender) {
            uint256 prize = epoch.finalBal - epoch.initialBal;
            aurora.transfer(msg.sender, prize);
            for (uint256 i; i < streamTokens.length;) {
                uint256 bal = streamTokens[i].balanceOf(address(this));
                streamTokens[i].transfer(msg.sender, bal);
                unchecked {
                    i++;
                }
            }
        }
        userTickets[_epochId][msg.sender].claimed = true;
    }

    function claimLatest() external {
        claimTickets(epochs.length - 2);
    }

    // @notice Allows admin to close an epoch and computes the winner
    // @dev Function updates epoch variables and moves all rewardstoPending.
    function concludeEpoch() external onlyAdmin {
        uint256 epochId = epochs.length - 1;
        Epoch storage currentEpoch = epochs[epochId];
        require(currentEpoch.status == Status.Active, "NO_LIVE_EPOCH");
        address winningAddress = computeWinner(epochId);
        currentEpoch.endTime = block.timestamp;
        currentEpoch.status = Status.Ended;
        // currentEpoch.winner = winningAddress;
        uint256 auroraBal = (jetStaking.getTotalAmountOfStakedAurora() * jetStaking.getUserShares(address(this)))
            / jetStaking.totalAuroraShares();
        currentEpoch.finalBal = auroraBal;
        jetStaking.moveAllRewardsToPending();
        jetStaking.unstakeAll();
    }

    // @notice Allows admin to withdraw tokens once the 2 day delay is over
    // @notice _epochId Allows function to know which epochId to update
    function withdraw(uint256 _epochId) external onlyAdmin {
        jetStaking.withdrawAll();
        epochs[_epochId].withdrawalOpen = true;
    }

    // @notice Creates a new epoch and pushes to the array
    function newEpoch() public onlyAdmin {
        epochs.push(Epoch(block.timestamp, 0, 0, 0, address(0), false, Status.Active));
    }

    /*/////////////////////////////////////////////////////
                    HELPER FUNCTIONS
    /////////////////////////////////////////////////////*/

    function randomSeed() public returns (uint256) {
        bytes32[1] memory value;

        assembly {
            let ret := call(gas(), 0xc104f4840573bed437190daf5d2898c2bdf928ac, 0, 0, 0, value, 32)
        }

        return uint256(value[0]);
    }

    // @notice Function computes the winner for a specific epoch
    // @param epochId Id of epoch we want to compute winner for
    // @dev The winner is computed by getting a random uint256 number
    //      We then divide this random number by the total aurora deposited
    //      in the specified epoch, and take the remainder. (we add 1 because
    //      the modulo can be 0 - n-1, and we need a number from 1 to n)
    //      Whicheve address has a *cumulative* aurora balance higher than the
    //      winning number is the winning address.
    function computeWinner(uint256 epochId) public returns (address winningAddress) {
        uint256 randNum = randomSeed();
        uint256 totalAurora = epochs[epochId].initialBal;
        uint256 winningNum = (randNum % totalAurora) + 1;
        winningAddress = binarySearch(cumulativeTickets[epochId], winningNum);
    }

    function binarySearch(Tickets[] memory arr, uint256 value) public pure returns (address) {
        // First, we need to store the start and end indices of the array
        int256 start = 0;
        int256 end = int256(arr.length - 1);

        // We also need to store the index of the lowest value that is larger than the target value
        int256 nextIndex = 0;

        // Then, we can use a loop to perform the binary search
        while (start <= end) {
            // Calculate the midpoint of the current array section
            int256 mid = (start + end) / 2;

            // If the value at the midpoint is the target value, we can return the index
            if (arr[uint256(mid)].amountCumulative == value) {
                return arr[uint256(mid)].owner;
            }

            // If the value at the midpoint is larger than the target value, we can update
            // the next index and adjust the end index of the array
            if (arr[uint256(mid)].amountCumulative > value) {
                nextIndex = mid;
                end = mid - 1;
            } 
            // Otherwise, we can adjust the start index of the array
            else {
                start = mid + 1;
            }
        }

        // If the value is not found in the array, we can return the index of the next value
        return arr[uint256(nextIndex)].owner;
    }

    function stake() external onlyAdmin {
        jetStaking.stake(aurora.balanceOf(address(this)));
    }

    function setAdmin(address _admin) external onlyAdmin {
        admin = _admin;
    }

    function setOpenWindow(uint256 _time) external onlyAdmin {
        openWindow = _time;
    }

    function pause() external onlyAdmin {
        paused = true;
    }

    function unPause() external onlyAdmin {
        paused = false;
    }

    function getWinner(uint256 _epochId) view external returns (address) {
        return epochs[_epochId].winner;
    }
}
